/**
 * @file
 *
 * @author Generated by spec2x
 * $Rev$
 * $Date$
 */
#ifndef BIM_PNODE_HPP
#define BIM_PNODE_HPP

#include "bi/model/BayesNode.hpp"
#include "bi/state/Coord.hpp"
#include "bi/cuda/cuda.hpp"
#include "bi/math/scalar.hpp"
#include "bi/misc/compile.hpp"

#ifdef USE_SSE
#include "bi/math/sse.hpp" // overloads of standard math functions
#endif

/**
 * \f\$P\f\$; 
 */
class PNode : public bi::BayesNode {
public:
  /**
   * Constructor.
   */
  PNode();

  /**
   * @see bi::ODEForwardFunction::dfdt
   */
  template<class T, class V1, class V2>
  static CUDA_FUNC_BOTH void dfdt(const bi::Coord& cox, const T t,
      const V1& pax, V2& dfdt);
  
  /**
   * Prior mean.
   */
  static real mu0();

  /**
   * Prior standard deviation.
   */
  static real sigma0();
    

};

#include "bi/model/model.hpp"
#include "bi/traits/type_traits.hpp"
#include "bi/traits/dimension_traits.hpp"
#include "bi/traits/boundary_traits.hpp"
#include "bi/traits/forward_traits.hpp"
#include "bi/traits/prior_traits.hpp"





HAS_LOG_NORMAL_PRIOR(PNode);
IS_C_NODE(PNode);
IS_ODE_FORWARD(PNode);


#include "PgNode.hpp"

#include "PNode.hpp"
#include "ZNode.hpp"





template<class T1, class V1, class V2>
inline void PNode::dfdt(const bi::Coord& cox, const T1 t,
    const V1& pax, V2& dfdt) {
  BI_UNUSED const V2 Pg = pax.template fetch<PgNode,0,0,0>(cox);

  BI_UNUSED const V2 P = pax.template fetch<PNode,0,0,0>(cox);
  BI_UNUSED const V2 Z = pax.template fetch<ZNode,0,0,0>(cox);




  BI_UNUSED const V2 ZCl = REAL(0.25);

  
if (true) {
    dfdt = Pg*P - ZCl*P*Z;
  }


}

inline real PNode::mu0() {
  real result;
  
if (true) {
    result = CUDA_LOG(REAL(2.0));
  }



  return result;
}

inline real PNode::sigma0() {
  real result;
  
if (true) {
    result = REAL(0.2);
  }



  return result;
}






#endif

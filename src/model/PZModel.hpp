
/**
 * @file
 *
 * @author Generated by spec2x
 * $Rev$
 * $Date$
 */
#ifndef BIM_PZMODEL_HPP
#define BIM_PZMODEL_HPP

#include "EPgNode.hpp"
#include "VPgNode.hpp"
#include "RPgNode.hpp"
#include "PgNode.hpp"
#include "PNode.hpp"
#include "ZNode.hpp"
#include "P_obsNode.hpp"

#include "bi/model/BayesNet.hpp"
#include "bi/model/model.hpp"
#include "bi/typelist/TypeList.hpp"
#include "bi/pdf/FactoredPdf.hpp"
#include "bi/pdf/ExpGaussianPdf.hpp"
#include "bi/pdf/UniformPdf.hpp"

#include <vector>

/**
 * Type list for s-nodes.
 */
BEGIN_TYPELIST(PZSTypeList)
END_TYPELIST()

/**
 * Type list for d-nodes.
 */
BEGIN_TYPELIST(PZDTypeList)
SINGLE_TYPE(1, PgNode)
END_TYPELIST()

/**
 * Type list for c-nodes.
 */
BEGIN_TYPELIST(PZCTypeList)
SINGLE_TYPE(1, PNode)
SINGLE_TYPE(1, ZNode)
END_TYPELIST()

/**
 * Type list for r-nodes.
 */
BEGIN_TYPELIST(PZRTypeList)
SINGLE_TYPE(1, RPgNode)
END_TYPELIST()

/**
 * Type list for f-nodes.
 */
BEGIN_TYPELIST(PZFTypeList)
END_TYPELIST()

/**
 * Type list for o-nodes.
 */
BEGIN_TYPELIST(PZOTypeList)
SINGLE_TYPE(1, P_obsNode)
END_TYPELIST()

/**
 * Type list for p-nodes.
 */
BEGIN_TYPELIST(PZPTypeList)
SINGLE_TYPE(1, EPgNode)
SINGLE_TYPE(1, VPgNode)
END_TYPELIST()


/* s-parents */

/* d-parents */
SET_PA(d, PNode, 0, PgNode, 0, 0, 0)

/* c-parents */
SET_PA(c, PNode, 0, PNode, 0, 0, 0)
SET_PA(c, PNode, 1, ZNode, 0, 0, 0)
SET_PA(c, ZNode, 0, ZNode, 0, 0, 0)
SET_PA(c, ZNode, 1, PNode, 0, 0, 0)
SET_PA(c, P_obsNode, 0, PNode, 0, 0, 0)

/* r-parents */
SET_PA(r, PgNode, 0, RPgNode, 0, 0, 0)

/* f-parents */

/* p-parents */
SET_PA(p, PgNode, 0, EPgNode, 0, 0, 0)
SET_PA(p, PgNode, 1, VPgNode, 0, 0, 0)

BEGIN_TYPELIST(PZDPriorTypeList)
SINGLE_TYPE(bi::node_dimlens<PgNode>::value, bi::ExpGaussianPdf<>)
END_TYPELIST()


BEGIN_TYPELIST(PZCPriorTypeList)
SINGLE_TYPE(bi::node_dimlens<PNode>::value, bi::ExpGaussianPdf<>)
SINGLE_TYPE(bi::node_dimlens<ZNode>::value, bi::ExpGaussianPdf<>)
END_TYPELIST()


BEGIN_TYPELIST(PZPPriorTypeList)
SINGLE_TYPE(bi::node_dimlens<EPgNode>::value, bi::ExpGaussianPdf<>)
SINGLE_TYPE(bi::node_dimlens<VPgNode>::value, bi::ExpGaussianPdf<>)
END_TYPELIST()


/**
 * Prior type selector for PZModel.
 *
 * @tparam type Node type.
 */
template<bi::NodeType type>
struct PZModelPriorType {
  //
};

template<>
struct PZModelPriorType<bi::D_NODE> {
  typedef bi::FactoredPdf<GET_TYPELIST(PZDPriorTypeList)> type; 
};

template<>
struct PZModelPriorType<bi::C_NODE> {
  typedef bi::FactoredPdf<GET_TYPELIST(PZCPriorTypeList)> type; 
};

template<>
struct PZModelPriorType<bi::P_NODE> {
  typedef bi::FactoredPdf<GET_TYPELIST(PZPPriorTypeList)> type; 
};

/**
 * 
 *
 * @tparam XN Size of x-dimension.
 * @tparam YN Size of y-dimension.
 * @tparam ZN Size of z-dimension.
 */
template<int XN = 1, int YN = 1, int ZN = 1>
class PZModel : public bi::BayesNet {
public:
  /**
   * Type list for s-net.
   */
  typedef GET_TYPELIST(PZSTypeList) STypeList;
  
  /**
   * Type list for d-net.
   */
  typedef GET_TYPELIST(PZDTypeList) DTypeList;
  
  /**
   * Type list for c-net.
   */
  typedef GET_TYPELIST(PZCTypeList) CTypeList;
  
  /**
   * Type list for r-net.
   */
  typedef GET_TYPELIST(PZRTypeList) RTypeList;
  
  /**
   * Type list for f-net.
   */
  typedef GET_TYPELIST(PZFTypeList) FTypeList;
  
  /**
   * Type list for o-net.
   */
  typedef GET_TYPELIST(PZOTypeList) OTypeList;
  
  /**
   * Type list for p-net.
   */
  typedef GET_TYPELIST(PZPTypeList) PTypeList;
  
  /**
   * Type list for factored prior over d-net.
   */
  typedef typename PZModelPriorType<bi::D_NODE>::type DPriorTypeList;
  
  /**
   * Type list for factored prior over c-net.
   */
  typedef typename PZModelPriorType<bi::C_NODE>::type CPriorTypeList;
  
  /**
   * Type list for factored prior over p-net.
   */
  typedef typename PZModelPriorType<bi::P_NODE>::type PPriorTypeList;
    
  /**
   * Size of x-dimension.
   */
  static const int NX = XN;
  
  /**
   * Size of y-dimension.
   */
  static const int NY = YN;
  
  /**
   * Size of z-dimension.
   */
  static const int NZ = ZN;
  
  /**
   * Constructor.
   */
  PZModel();
  
  /**
   * Destructor.
   */
  ~PZModel();

  /**
   * Get prior over nodes of given type.
   *
   * @tparam type Node type.
   *
   * @return Prior over nodes of given type.
   */
  template<bi::NodeType type>
  typename PZModelPriorType<type>::type& getPrior();

private:
  /*
   * Nodes.
   */
  EPgNode nodeEPg;
  VPgNode nodeVPg;
  RPgNode noderPg;
  PgNode nodePg;
  PNode nodeP;
  ZNode nodeZ;
  P_obsNode nodeP_obs;
  
  /**
   * Priors.
   */
  std::vector<void*> priors;

};

#include "bi/traits/prior_traits.hpp"
#include "bi/traits/likelihood_traits.hpp"
#include "bi/math/host_vector.hpp"
#include "bi/math/host_matrix.hpp"

template<int XN, int YN, int ZN>
PZModel<XN,YN,ZN>::PZModel() : priors(bi::NUM_NODE_TYPES, NULL) {
  using namespace bi;
  int i;

  init<PZModel>();

  /* nodes */
  addNode<PZModel,EPgNode>(nodeEPg);
  addNode<PZModel,VPgNode>(nodeVPg);
  addNode<PZModel,RPgNode>(noderPg);
  addNode<PZModel,PgNode>(nodePg);
  addNode<PZModel,PNode>(nodeP);
  addNode<PZModel,ZNode>(nodeZ);
  addNode<PZModel,P_obsNode>(nodeP_obs);

  /* edges */
  addArc(nodeEPg, nodePg, 0, 0, 0);
  addArc(nodeP, nodeP, 0, 0, 0);
  addArc(nodeP, nodeP_obs, 0, 0, 0);
  addArc(nodePg, nodeP, 0, 0, 0);
  addArc(nodeZ, nodeZ, 0, 0, 0);
  addArc(noderPg, nodePg, 0, 0, 0);
  addArc(nodeP, nodeZ, 0, 0, 0);
  addArc(nodeVPg, nodePg, 0, 0, 0);
  addArc(nodeZ, nodeP, 0, 0, 0);

  /* priors */ 
  priors[D_NODE] = new typename PZModelPriorType<D_NODE>::type();
  priors[C_NODE] = new typename PZModelPriorType<C_NODE>::type();
  priors[P_NODE] = new typename PZModelPriorType<P_NODE>::type();
    
  ExpGaussianPdf<> c0(nodeP.mu0(), nodeP.sigma0(), true);
  for (i = 0; i < getNodeSize(C_NODE, 0); ++i) {
    getPrior<C_NODE>().set(getNodeStart(C_NODE, 0) + i, c0);
  }
  
  ExpGaussianPdf<> c1(nodeZ.mu0(), nodeZ.sigma0(), true);
  for (i = 0; i < getNodeSize(C_NODE, 1); ++i) {
    getPrior<C_NODE>().set(getNodeStart(C_NODE, 1) + i, c0);
  }
    
  ExpGaussianPdf<> p0(nodeEPg.mu0(), nodeEPg.sigma0(), true);
  for (i = 0; i < getNodeSize(P_NODE, 0); ++i) {
    getPrior<P_NODE>().set(getNodeStart(P_NODE, 0) + i, p0);
  }
  
  ExpGaussianPdf<> p1(nodeVPg.mu0(), nodeVPg.sigma0(), true);
  for (i = 0; i < getNodeSize(P_NODE, 1); ++i) {
    getPrior<P_NODE>().set(getNodeStart(P_NODE, 1) + i, p0);
  }
    
}

template<int XN, int YN, int ZN>
PZModel<XN,YN,ZN>::~PZModel() {
  using namespace bi;

  delete &getPrior<D_NODE>();
  delete &getPrior<C_NODE>();
  delete &getPrior<P_NODE>();
}

template<int XN, int YN, int ZN>
template<bi::NodeType type>
inline typename PZModelPriorType<type>::type& PZModel<XN,YN,ZN>::getPrior() {
  using namespace bi;

  /* pre-condition */
  assert (type == D_NODE || type == C_NODE || type == P_NODE || false);

  return *static_cast<typename PZModelPriorType<type>::type*>(priors[type]);
}

#endif

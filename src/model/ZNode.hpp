/**
 * @file
 *
 * @author Generated by spec2x
 * $Rev$
 * $Date$
 */
#ifndef BIM_ZNODE_HPP
#define BIM_ZNODE_HPP

#include "bi/model/BayesNode.hpp"
#include "bi/state/Coord.hpp"
#include "bi/cuda/cuda.hpp"
#include "bi/math/scalar.hpp"
#include "bi/misc/compile.hpp"

#ifdef USE_SSE
#include "bi/math/sse.hpp" // overloads of standard math functions
#endif

/**
 * \f\$Z\f\$; 
 */
class ZNode : public bi::BayesNode {
public:
  /**
   * Constructor.
   */
  ZNode();

  /**
   * @see bi::ODEForwardFunction::dfdt
   */
  template<class T, class V1, class V2>
  static CUDA_FUNC_BOTH void dfdt(const bi::Coord& cox, const T t,
      const V1& pax, V2& dfdt);
  
  /**
   * Prior mean.
   */
  static real mu0();

  /**
   * Prior standard deviation.
   */
  static real sigma0();
    

};

#include "bi/model/model.hpp"
#include "bi/traits/type_traits.hpp"
#include "bi/traits/dimension_traits.hpp"
#include "bi/traits/boundary_traits.hpp"
#include "bi/traits/forward_traits.hpp"
#include "bi/traits/prior_traits.hpp"





HAS_LOG_NORMAL_PRIOR(ZNode);
IS_C_NODE(ZNode);
IS_ODE_FORWARD(ZNode);



#include "ZNode.hpp"
#include "PNode.hpp"





template<class T1, class V1, class V2>
inline void ZNode::dfdt(const bi::Coord& cox, const T1 t,
    const V1& pax, V2& dfdt) {

  BI_UNUSED const V2 Z = pax.template fetch<ZNode,0,0,0>(cox);
  BI_UNUSED const V2 P = pax.template fetch<PNode,0,0,0>(cox);




  BI_UNUSED const V2 ZCl = REAL(0.25);
  BI_UNUSED const V2 ZgE = REAL(0.3);
  BI_UNUSED const V2 ZmL = REAL(0.1);
  BI_UNUSED const V2 ZmQ = REAL(0.1);

  
if (true) {
    dfdt = ZCl*ZgE*P*Z - ZmL*Z - ZmQ*Z*Z;
  }


}

inline real ZNode::mu0() {
  real result;
  
if (true) {
    result = CUDA_LOG(REAL(2.0));
  }



  return result;
}

inline real ZNode::sigma0() {
  real result;
  
if (true) {
    result = REAL(0.1);
  }



  return result;
}






#endif

/**
 * @file
 *
 * @author Generated by spec2x
 * $Rev$
 * $Date$
 */
#ifndef BIM_PGNODE_HPP
#define BIM_PGNODE_HPP

#include "bi/model/BayesNode.hpp"
#include "bi/state/Coord.hpp"
#include "bi/cuda/cuda.hpp"
#include "bi/math/scalar.hpp"
#include "bi/misc/compile.hpp"

#ifdef USE_SSE
#include "bi/math/sse.hpp" // overloads of standard math functions
#endif

/**
 * \f\$Pg\f\$; 
 */
class PgNode : public bi::BayesNode {
public:
  /**
   * Constructor.
   */
  PgNode();

  /**
   * @see bi::GenericForwardFunction::f
   */
  template<class T, class V1, class V2>
  static CUDA_FUNC_BOTH void f(const bi::Coord& cox, const T t, const V1& pax,
      const T tnxt, V2& xnxt);
  
  /**
   * Prior mean.
   */
  static real mu0();

  /**
   * Prior standard deviation.
   */
  static real sigma0();
    

};

#include "bi/model/model.hpp"
#include "bi/traits/type_traits.hpp"
#include "bi/traits/dimension_traits.hpp"
#include "bi/traits/boundary_traits.hpp"
#include "bi/traits/forward_traits.hpp"
#include "bi/traits/prior_traits.hpp"





HAS_GAUSSIAN_PRIOR(PgNode);
IS_D_NODE(PgNode);
IS_GENERIC_FORWARD(PgNode);




#include "RPgNode.hpp"


#include "EPgNode.hpp"
#include "VPgNode.hpp"


template<class T1, class V1, class V2>
inline void PgNode::f(const bi::Coord& cox, const T1 t, const V1& pax,
    const T1 tnxt, V2& xnxt) {


  BI_UNUSED const V2 rPg = pax.template fetch<RPgNode,0,0,0>(cox);


  BI_UNUSED const V2 EPg = pax.template fetch<EPgNode,0,0,0>(cox);
  BI_UNUSED const V2 VPg = pax.template fetch<VPgNode,0,0,0>(cox);


  
if (true) {
    xnxt = VPg*rPg+EPg;
  }


}

inline real PgNode::mu0() {
  real result;
  
if (true) {
    result = REAL(0.25);
  }



  return result;
}

inline real PgNode::sigma0() {
  real result;
  
if (true) {
    result = REAL(0.1);
  }



  return result;
}






#endif
